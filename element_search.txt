Ниже приведены части элементов HTML-страницы, по которым можно найти элемент:

- id (ищем через знак #, то есть "#название_элемента");
- tag (ищем через название тега, типа p, h1, div и пр.; тегов очень много = такой метод неудобен);
- значение атрибута (ищем по схеме "[название_атрибута=значение]", например "[value=logo]");
- name (аналогично поиску по атрибуду, но в качестве атрибута - name);
- class (поиск через точку, то есть .имя_класса).

ЕЩЁ КОЕ-ЧТО:

* Использовать поиск по атрибуду можно в качестве альтернативы поиска по id или классу (вместо "#id_value" искать "[id=value]"). Проблема в том, 
что такой поиск ищет только точное совпадение. Если у элемента несколько классов, то поиск по одному из них не даст результатов;
* Поиск чувствителен к регистру: значения value, Value и vAlUe - разные;
* Поиск можно делать и по содержимому страницы, например, по тексту. Однако делать этого не стоит: такой поиск очень не точен;

==============================================================================

+++ КОМБИНИРОВАННЫЕ СЕЛЕКТОРЫ +++

Описанные выше селекторы можно комбинировать. Делать это можно как просто прописывая селекторы один за другим, так и через пробел.

* Если мы пишем селекторы друг за другом (например, "#id.class"), это значит, что мы ищем элемент, в котором есть и указанный id, и указанный класс;
* Если мы используем пробел ("#id .class"), то это значит, что мы ищем дочерний элемент с классом class в родительском элементе с айдишником id;
------------------------------------------------------------------------------
Другой способ - использование дочерних элементов. Для этого используем знак ">". Элемент слева будет "родительским", элемент справа - "дочерним".
Например, ".class > #id". Значит, поиск пройдет в классе class по дочернему элементу с айдишником id.
------------------------------------------------------------------------------
Третий способ - использование класса :nth-child(). В скобках указываем номер дочернего элемента, который хотим найти.
Например, ".class > p:nth-child(3) > #id". Это значит, что поиск будет проведён в элементе с классом class, третьем элементе с тегом p и 
айдишником id.
------------------------------------------------------------------------------
Если у элемента несколько классов, можно провести поиск по ним, описав классы друг за другом, например ".class1.class2"

==============================================================================


--- XPath ---

Запросы типа Xpath всегда начинаются с символа "/" и указания корневого каталога, т.е. элемента htlm. Например, "/html/body//div[contains(@class, "lesson")]". 
Запрос также можно начать с "//", тогда мы будем искать ВСЕ дочерние элементы головного каталога любой вложенности.

* По аналогии с указанием дочерних элементов через ">", в XPath используется символ "/". То есть "element1/element2", где элемент element2 - прямой (это важно!) 
потомок element2;
* Для указания вложенности любой степени, используется "//". Это значит, что элемент справа будет потомком любой вложенности у элемента слева.

Для дополнительной фильтрации можно использовать квадратные скобки "[]". Внутри них следует описать условие, по которому будет проходить поиск.


