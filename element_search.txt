Ниже приведены части элементов HTML-страницы, по которым можно найти элемент:

- id (ищем через знак #, то есть "#название_элемента");
- tag (ищем через название тега, типа p, h1, div и пр.; тегов очень много = такой метод неудобен);
- значение атрибута (ищем по схеме "[название_атрибута=значение]", например "[value=logo]");
- name (аналогично поиску по атрибуту, но в качестве атрибута - name);
- class (поиск через точку, то есть .имя_класса).

ЕЩЁ КОЕ-ЧТО:

* Использовать поиск по атрибуду можно в качестве альтернативы поиска по id или классу (вместо "#id_value" искать "[id=value]"). Проблема в том, 
что такой поиск ищет только точное совпадение. Если у элемента несколько классов, то поиск по одному из них не даст результатов;
* Поиск чувствителен к регистру: значения value, Value и vAlUe - разные;
* Поиск можно делать и по содержимому страницы, например, по тексту. Однако делать этого не стоит: такой поиск очень не точен;


==============================================================================


+++ КОМБИНИРОВАННЫЕ СЕЛЕКТОРЫ +++

Описанные выше селекторы можно комбинировать. Делать это можно как просто прописывая селекторы один за другим, так и через пробел.

* Если мы пишем селекторы друг за другом (например, "#id.class"), это значит, что мы ищем элемент, в котором есть и указанный id, и указанный класс;
* Если мы используем пробел ("#id .class"), то это значит, что мы ищем дочерний элемент с классом class в родительском элементе с айдишником id;
------------------------------------------------------------------------------
Другой способ - использование дочерних элементов. Для этого используем знак ">". Элемент слева будет "родительским", элемент справа - "дочерним".
Например, ".class > #id". Значит, поиск пройдет в классе class по дочернему элементу с айдишником id.
------------------------------------------------------------------------------
Третий способ - использование класса :nth-child(). В скобках указываем номер дочернего элемента, который хотим найти.
Например, ".class > p:nth-child(3) > #id". Это значит, что поиск будет проведён в элементе с классом class, третьем элементе с тегом p и 
айдишником id.
------------------------------------------------------------------------------
Если у элемента несколько классов, можно провести поиск по ним, описав классы друг за другом, например ".class1.class2"


==============================================================================


--- XPath ---

Запросы типа Xpath всегда начинаются с символа "/" и указания корневого каталога, т.е. элемента htlm. Например, "/html/body//div[contains(@class, "lesson")]". 
Запрос также можно начать с "//", тогда мы будем искать ВСЕ дочерние элементы головного каталога любой вложенности.

* По аналогии с указанием дочерних элементов через ">", в XPath используется символ "/". То есть "element1/element2", где элемент element2 - прямой (это важно!) 
потомок element2;
* Для указания вложенности любой степени, используется "//". Это значит, что элемент справа будет потомком любой вложенности у элемента слева.

Для дополнительной фильтрации можно использовать квадратные скобки "[]". Внутри них следует описать условие, по которому будет проходить поиск. Существует 
несколько правил фильтрации:

* По любому атрибуту, будь то id, class, title (или любой другой). Например, запрос "//img[@id='bullet']" выполнит поиск любого элемента img с id=bullet;
* По порядковому номеру. Например, мы ищем элемент с классом "row" и хотим взять его второго потомка: "//div[@class="row"]/div[2]";
* По полному совпадению текста. Запрос типа "//p[text()="value"]" выполнит поиск элемента p (текст), текст в котором совпадает со значением в скобках. 
ВНИМАНИЕ: работает только если текст совпадает полностью;
* По частичному совпадению. Запрос "//p[contains(text(), "cat")]" найдёт все элементы p, содержащие текст "cat". Поиск также может работать и 
по другим атрибутам: по имени класса или id (прописываем это значение через @ в теле запроса, например "//div[contains(@id, "value")]");
* Запросы можно соединять при помощи логических операций AND, OR и NOT. Например, если мы ищем картинку с id=value1 и data-type=value2, два этих 
атрибута можно объединить - "//img[@id="value1" AND @data-type="value2"];
* Для того, чтобы найти все элементы, которые удовлетворяют заданному условию, используется символ "*". Например, //*[@class="value"].

Запросы XPath регистрозависимы.


==============================================================================


\\\ Поиск элементов в SELENIUM WEB DRIVER///

* find_element_by_id — поиск по уникальному атрибуту id элемента. Если ваши разработчики проставляют всем элементам в приложении уникальный id, то вам повезло, и вы чаще всего будет использовать этот метод, так как он наиболее стабильный;
* find_element_by_css_selector — поиск элемента с помощью правил на основе CSS. Это универсальный метод поиска, так как большинство веб-приложений использует CSS для вёрстки и задания оформления страницам. Если find_element_by_id вам не подходит из-за отсутствия id у элементов, то скорее всего вы будете использовать именно этот метод в ваших тестах;
* find_element_by_xpath — поиск с помощью языка запросов XPath, позволяет выполнять очень гибкий поиск элементов;
* find_element_by_name — поиск по атрибуту name элемента;
* find_element_by_tag_name — поиск элемента по названию тега элемента;
* find_element_by_class_name — поиск по значению атрибута class;
* find_element_by_link_text — поиск ссылки на странице по полному совпадению;
* find_element_by_partial_link_text — поиск ссылки на странице, если текст селектора совпадает с любой частью текста ссылки.